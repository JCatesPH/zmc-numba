{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Test to ensure modifications to function do not change evaluated value\n",
    "\n",
    "I have written functions for Heaviside and Bessel functions (only first-kind, zero-order) and extended the Bessel function series to eight terms.\n",
    "\n",
    "A lot of steps have been broken into smaller steps for CUDA to understand it."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "import math\n",
    "from numba import cuda\n",
    "import ZMCIntegral\n",
    "import time\n",
    "import numpy as np\n",
    "import scipy\n",
    "import scipy.special\n",
    "from scipy.integrate import quad\n",
    "\n",
    "import matplotlib\n",
    "import matplotlib.pyplot as plt\n",
    "from matplotlib.colors import BoundaryNorm\n",
    "from matplotlib.ticker import MaxNLocator"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Define constants in function"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "mu = 0.1  # Fermi-level\n",
    "hOmg = 0.5  # Photon energy eV\n",
    "a = 4  # AA\n",
    "A = 4  # hbar^2/(2m)=4 evAA^2 (for free electron mass)\n",
    "rati = 0.3  # ratio\n",
    "eE0 = rati * ((hOmg) ** 2) / (2 * np.sqrt(A * mu))\n",
    "# print(eE0)\n",
    "Gamm = 0.005  # Gamma in eV.\n",
    "KT = 1 * 10 ** (-6)\n",
    "shift = A * (eE0 / hOmg) ** 2"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Function given with major modifications. I replaced all calls to kx, ky, qx, and qy with x[0], x[1], x[2], and x[3] respectively. This modification effectively \"vectorizes\" the input. I have written my own Bessel of first-kind function and Heaviside function to cast into CUDA.\n",
    "\n",
    "These modifications, however, have made the function only apply to this single case. Extending the ability will take more effort, but can be done with time. Analysis of how well this modified function evaluates to the proper value is below.\n",
    "\n",
    "Commented out lines are those which I changed, and there should be explanations or some clarity on the changes."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "sing = np.array([0.])\n",
    "\n",
    "def my_heaviside(z): \n",
    "    # Wrote this Heaviside expression with it cast in cuda to avoid error below.\n",
    "    if z <= 0 :\n",
    "\t    return 0\n",
    "    else :\n",
    "\t    return 1\n",
    "\n",
    "def my_Bessel(z):\n",
    "    # CHANGE FOR v4: Changing polynomial evaluation for efficiency (SEE Horner's Algorithm). Extending number of terms.\n",
    "    # Carrying the series to eight terms ensures that the error in the series is < machine_epsilon when z < 1. \n",
    "    # Approximately: z1 <~ 2.1, z2 <~ 3.33  implies  error <~ 2.15E-6 for Bessel. Total averror calculated to be E-16\n",
    "    val = z**2 / 4 * (-1 + z**2 / 16 * (1 + z**2 / 36 * (-1 + z**2 / 64 * (1 + z**2 / 100 * (-1 + z**2 / 144 * (1 + z**2 / 196 * (-1 + z**2 / 256)))))))\n",
    "    return val + 1\n",
    "\n",
    "def modDs_real(x):\n",
    "    dds = 0\n",
    "    ek = A * (math.sqrt((x[0]) ** 2 + (x[1]) ** 2)) ** 2 + A * (eE0 / hOmg) ** 2\n",
    "    ekq = A * (math.sqrt((x[0] + x[2]) ** 2 + (x[1] + x[3]) ** 2)) ** 2 + A * (eE0 / hOmg) ** 2\n",
    "    xk = 2 * A * eE0 * math.sqrt((x[0]) ** 2 + (x[1]) ** 2) / hOmg ** 2\n",
    "    xkq = 2 * A * eE0 * math.sqrt((x[0] + x[2]) ** 2 + (x[1] + x[3]) ** 2) / hOmg ** 2\n",
    "\n",
    "    ts1 = ek - hOmg / 2\n",
    "    ts2 = ekq - hOmg / 2\n",
    "    ts3 = ek + hOmg / 2\n",
    "    ts4 = ekq + hOmg / 2\n",
    "\n",
    "    arc2ts1 = math.atan2(Gamm, ts1)\n",
    "    arc2ts2 = math.atan2(Gamm, ts2)\n",
    "    arc2ts3 = math.atan2(Gamm, ts3)\n",
    "    arc2ts4 = math.atan2(Gamm, ts4)\n",
    "\n",
    "    taninv1kp = 2 * arc2ts1\n",
    "    taninv1kqp = 2 * arc2ts2\n",
    "    taninv1km = 2 * arc2ts3\n",
    "    taninv1kqm = 2 * arc2ts4\n",
    "\n",
    "    squared1 = ek - hOmg/2\n",
    "    squared2 = ekq - hOmg/2\n",
    "    squared3 = ek + hOmg/2\n",
    "    squared4 = ekq + hOmg/2\n",
    "\n",
    "    logged1 = Gamm**2 + squared1**2\n",
    "    logged2 = Gamm**2 + squared2**2\n",
    "    logged3 = Gamm**2 + squared3**2\n",
    "    logged4 = Gamm**2 + squared4**2\n",
    "\n",
    "    logged1 = Gamm**2 + (ek - hOmg/2)**2\n",
    "    logged2 = Gamm**2 + (ekq - hOmg/2)**2\n",
    "    logged3 = Gamm**2 + (ek + hOmg/2)**2\n",
    "    logged4 = Gamm**2 + (ekq + hOmg/2)**2\n",
    "\n",
    "    ln1 = math.log(logged1)\n",
    "    ln2 = math.log(logged2)\n",
    "    ln3 = math.log(logged3)\n",
    "    ln4 = math.log(logged4)\n",
    "\n",
    "    lg1kp = complex(0, 1) * ln1\n",
    "    lg1kqp = complex(0, 1) * ln2\n",
    "    lg1km = complex(0, 1) * ln3\n",
    "    lg1kqm = complex(0, 1) * ln4\n",
    "\t\n",
    "    heavi1 = mu - hOmg / 2\n",
    "    heavi2 = mu + hOmg / 2\n",
    "\n",
    "    ferp = my_heaviside(heavi1)\n",
    "    ferm = my_heaviside(heavi2)\n",
    "\n",
    "    taninv2k = 2 * math.atan2(Gamm, ek - mu)\n",
    "    taninv2kq = 2 * math.atan2(Gamm, ekq - mu)\n",
    "\n",
    "    lg2k = complex(0, 1) * math.log(Gamm ** 2 + (ek - mu) ** 2)\n",
    "    lg2kq = complex(0, 1) * math.log(Gamm ** 2 + (ekq - mu) ** 2)\n",
    "\n",
    "    besk = my_Bessel(xk)\n",
    "    beskq = my_Bessel(xkq)\n",
    "\n",
    "    fac1 = ek - ekq\n",
    "\n",
    "    fac2 = fac1 + 2 * complex(0, 1) * Gamm\n",
    "    fac3 = fac2 - ek + ekq\n",
    "\n",
    "\n",
    "    # NOTE: N = 1 implies all loops below will be evaluated once.\n",
    "    p1p = fac1 * (taninv1kp - taninv2k - lg1kp + lg2k)\n",
    "    p2p = fac2 * (taninv1kp - taninv2k + lg1kp - lg2k)\n",
    "    p3p = fac3 * (-taninv1kqp + taninv2kq - lg1kqp + lg2kq)\n",
    "\n",
    "    p1m = fac1 * (taninv1km - taninv2k - lg1km + lg2k)\n",
    "    p2m = fac2 * (taninv1km - taninv2k + lg1km - lg2k)\n",
    "    p3m = fac3 * (-taninv1kqm + taninv2kq - lg1kqm + lg2kq)\n",
    "\n",
    "    d1 = -2 * complex(0, 1) * fac1 * fac2 * fac3\n",
    "\n",
    "    omint1p = ferp * ((p1p + p2p + p3p) / d1)\n",
    "    omint1m = ferm * ((p1m + p2m + p3m) / d1)\n",
    "\n",
    "    bess1 = beskq * beskq * besk * besk * besk * besk\n",
    "\n",
    "    grgl = bess1 * (omint1p - omint1m)\n",
    "\n",
    "    pp1p = fac1 * (-taninv1kqp + taninv2kq - lg1kqp + lg2kq)\n",
    "    pp2p = fac2 * (-taninv1kqp + taninv2kq + lg1kqp - lg2kq)\n",
    "    pp3p = fac3 * (taninv1kp - taninv2k - lg1kp + lg2k)\n",
    "\n",
    "    pp1m = fac1 * (-taninv1kqm + taninv2kq - lg1kqm + lg2kq)\n",
    "    pp2m = fac2 * (-taninv1kqm + taninv2kq + lg1kqm - lg2kq)\n",
    "\n",
    "    pp3m = fac3 * (taninv1km - taninv2k - lg1km + lg2k)\n",
    "\n",
    "    d2 = -2 * complex(0, 1) * fac1 * fac2 * fac3\n",
    "\n",
    "    omint2p = ferp * ((pp1p + pp2p + pp3p) / d2)\n",
    "    omint2m = ferm * ((pp1m + pp2m + pp3m) / d2)\n",
    "\n",
    "    bess2 = beskq * beskq * beskq * beskq * besk * besk\n",
    "\n",
    "    glga = bess2 * (omint2p - omint2m)\n",
    "\n",
    "    dds = dds + 2 * Gamm * (grgl + glga)\n",
    "\n",
    "    return dds.real # / (8*math.pi**3)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The original function is declared below."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "def Ds(kx, ky, qx, qy):\n",
    "    N = 1\n",
    "    dds = 0\n",
    "    ds = 0\n",
    "    ek = A * (math.sqrt((kx) ** 2 + (ky) ** 2)) ** 2 + A * (eE0 / hOmg) ** 2\n",
    "    ekq = A * (math.sqrt((kx + qx) ** 2 + (ky + qy) ** 2)) ** 2 + A * (eE0 / hOmg) ** 2\n",
    "    xk = 2 * A * eE0 * math.sqrt((kx) ** 2 + (ky) ** 2) / hOmg ** 2\n",
    "    xkq = 2 * A * eE0 * math.sqrt((kx + qx) ** 2 + (ky + qy) ** 2) / hOmg ** 2\n",
    "\n",
    "    sing = np.arange(-(N - 1) / 2, (N - 1) / 2 + 1, 1)\n",
    "    taninv1kp = 2 * np.arctan2(Gamm, ek - hOmg / 2 + hOmg * sing)\n",
    "    taninv1kqp = 2 * np.arctan2(Gamm, ekq - hOmg / 2 + hOmg * sing)\n",
    "    taninv1km = 2 * np.arctan2(Gamm, ek + hOmg / 2 + hOmg * sing)\n",
    "    taninv1kqm = 2 * np.arctan2(Gamm, ekq + hOmg / 2 + hOmg * sing)\n",
    "\n",
    "    lg1kp = complex(0, 1) * np.log(Gamm ** 2 + (ek - hOmg / 2 + hOmg * sing) ** 2)\n",
    "    lg1kqp = complex(0, 1) * np.log(Gamm ** 2 + (ekq - hOmg / 2 + hOmg * sing) ** 2)\n",
    "    lg1km = complex(0, 1) * np.log(Gamm ** 2 + (ek + hOmg / 2 + hOmg * sing) ** 2)\n",
    "    lg1kqm = complex(0, 1) * np.log(Gamm ** 2 + (ekq + hOmg / 2 + hOmg * sing) ** 2)\n",
    "\n",
    "    ferp = np.heaviside(mu - hOmg / 2 - hOmg * sing, 0)\n",
    "    ferm = np.heaviside(mu + hOmg / 2 - hOmg * sing, 0)\n",
    "\n",
    "    dbl = np.arange(-(N - 1), (N - 1) + 1, 1)\n",
    "    taninv2k = 2 * np.arctan2(Gamm, ek - mu + hOmg * dbl)\n",
    "    taninv2kq = 2 * np.arctan2(Gamm, ekq - mu + hOmg * dbl)\n",
    "\n",
    "    lg2k = complex(0, 1) * np.log(Gamm ** 2 + (ek - mu + hOmg * dbl) ** 2)\n",
    "    lg2kq = complex(0, 1) * np.log(Gamm ** 2 + (ekq - mu + hOmg * dbl) ** 2)\n",
    "\n",
    "    besk = scipy.special.jv(dbl, xk)\n",
    "    beskq = scipy.special.jv(dbl, xkq)\n",
    "\n",
    "    fac1 = ek - ekq + hOmg * dbl\n",
    "    fac2 = fac1 + 2 * complex(0, 1) * Gamm\n",
    "    fac3 = fac2 - ek + ekq\n",
    "\n",
    "    for n in range(0, N):\n",
    "        for alpha in range(0, N):\n",
    "            for beta in range(0, N):\n",
    "                for gamma in range(0, N):\n",
    "                    for s in range(0, N):\n",
    "                        for l in range(0, N):\n",
    "                            p1p = fac1[beta - gamma + N - 1] * (\n",
    "                                    taninv1kp[alpha] - taninv2k[s + alpha] - lg1kp[alpha] + lg2k[s + alpha])\n",
    "                            p2p = fac2[alpha - gamma + N - 1] * (\n",
    "                                    taninv1kp[beta] - taninv2k[s + beta] + lg1kp[beta] - lg2k[s + beta])\n",
    "                            p3p = fac3[alpha - beta + N - 1] * (\n",
    "                                    -taninv1kqp[gamma] + taninv2kq[s + gamma] - lg1kqp[gamma] + lg2kq[\n",
    "                                s + gamma])\n",
    "\n",
    "                            p1m = fac1[beta - gamma + N - 1] * (\n",
    "                                    taninv1km[alpha] - taninv2k[s + alpha] - lg1km[alpha] + lg2k[s + alpha])\n",
    "\n",
    "                            p2m = fac2[alpha - gamma + N - 1] * (\n",
    "                                    taninv1km[beta] - taninv2k[s + beta] + lg1km[beta] - lg2k[s + beta])\n",
    "\n",
    "                            p3m = fac3[alpha - beta + N - 1] * (\n",
    "                                    -taninv1kqm[gamma] + taninv2kq[s + gamma] - lg1kqm[gamma] + lg2kq[\n",
    "                                s + gamma])\n",
    "\n",
    "                            d1 = -2 * complex(0, 1) * fac1[beta - gamma + N - 1] * fac2[alpha - gamma + N - 1] * \\\n",
    "                                 fac3[\n",
    "                                     alpha - beta + N - 1]\n",
    "\n",
    "                            omint1p = ferp[s] * ((p1p + p2p + p3p) / d1)\n",
    "\n",
    "                            omint1m = ferm[s] * ((p1m + p2m + p3m) / d1)\n",
    "\n",
    "                            bess1 = beskq[gamma - n + N - 1] * beskq[gamma - l + N - 1] * besk[beta - l + N - 1] * besk[\n",
    "                                beta - s + N - 1] * besk[alpha - s + N - 1] * besk[alpha - n + N - 1]\n",
    "\n",
    "                            grgl = bess1 * (omint1p - omint1m)\n",
    "\n",
    "                            pp1p = fac1[alpha - beta + N - 1] * (\n",
    "                                    -taninv1kqp[gamma] + taninv2kq[s + gamma] - lg1kqp[gamma] + lg2kq[\n",
    "                                s + gamma])\n",
    "\n",
    "                            pp2p = fac2[alpha - gamma + N - 1] * (\n",
    "                                    -taninv1kqp[beta] + taninv2kq[s + beta] + lg1kqp[beta] - lg2kq[\n",
    "                                s + beta])\n",
    "\n",
    "                            pp3p = fac3[beta - gamma + N - 1] * (\n",
    "                                    taninv1kp[alpha] - taninv2k[s + alpha] - lg1kp[alpha] + lg2k[s + alpha])\n",
    "\n",
    "                            pp1m = fac1[alpha - beta + N - 1] * (\n",
    "                                    -taninv1kqm[gamma] + taninv2kq[s + gamma] - lg1kqm[gamma] + lg2kq[\n",
    "                                s + gamma])\n",
    "\n",
    "                            pp2m = fac2[alpha - gamma + N - 1] * (\n",
    "                                    -taninv1kqm[beta] + taninv2kq[s + beta] + lg1kqm[beta] - lg2kq[\n",
    "                                s + beta])\n",
    "\n",
    "                            pp3m = fac3[beta - gamma + N - 1] * (\n",
    "                                    taninv1km[alpha] - taninv2k[s + alpha] - lg1km[alpha] + lg2k[s + alpha])\n",
    "\n",
    "                            d2 = -2 * complex(0, 1) * fac1[alpha - beta + N - 1] * fac2[alpha - gamma + N - 1] * \\\n",
    "                                 fac3[\n",
    "                                     beta - gamma + N - 1]\n",
    "\n",
    "                            omint2p = ferp[s] * ((pp1p + pp2p + pp3p) / d2)\n",
    "\n",
    "                            omint2m = ferm[s] * ((pp1m + pp2m + pp3m) / d2)\n",
    "\n",
    "                            bess2 = beskq[gamma - n + N - 1] * beskq[gamma - s + N - 1] * beskq[beta - s + N - 1] * \\\n",
    "                                    beskq[beta - l + N - 1] * besk[alpha - l + N - 1] * besk[alpha - n + N - 1]\n",
    "\n",
    "                            glga = bess2 * (omint2p - omint2m)\n",
    "\n",
    "                            dds = dds + 2 * Gamm * (grgl + glga)\n",
    "    return dds"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Comparing modified version and original\n",
      "================================================================================================\n",
      " kx  | ky  | qx  | qy  | Ds          | modDs  \n",
      "================================================================================================\n",
      "0.0  | 0.0 | 0.1 | 0   | -41.86649926328053  |  -41.86649926328055\n",
      "0.0  | 0.0 | 0.2 | 0   | -34.63780146737251  |  -34.63780146737251\n",
      "0.0  | 0.0 | 0.3 | 0   | -14.134014421216573  |  -14.134014421216571\n",
      "0.0  | 0.1 | 0.1 | 0   | -96.43684721789926  |  -96.43684721789921\n",
      "0.0  | 0.1 | 0.2 | 0   | -23.91771505962262  |  -23.917715059622612\n",
      "0.0  | 0.1 | 0.3 | 0   | -9.746602862432903  |  -9.7466028624329\n",
      "0.0  | 0.2 | 0.1 | 0   | -0.39732541568738206  |  -0.39732541568738206\n",
      "0.0  | 0.2 | 0.2 | 0   | -0.20160348539836384  |  -0.20160348539836392\n",
      "0.0  | 0.2 | 0.3 | 0   | -0.1007749790160859  |  -0.1007749790160859\n",
      "0.1  | 0.0 | 0.1 | 0   | -32.33742271129596  |  -32.337422711295936\n",
      "0.1  | 0.0 | 0.2 | 0   | -11.16701307138729  |  -11.167013071387283\n",
      "0.1  | 0.0 | 0.3 | 0   | -5.221550809191184  |  -5.221550809191182\n",
      "0.1  | 0.1 | 0.1 | 0   | -1.423292938420817  |  -1.423292938420817\n",
      "0.1  | 0.1 | 0.2 | 0   | -0.553803154735592  |  -0.553803154735592\n",
      "0.1  | 0.1 | 0.3 | 0   | -0.2662573690271028  |  -0.2662573690271027\n",
      "0.1  | 0.2 | 0.1 | 0   | -0.14086334206489237  |  -0.14086334206489243\n",
      "0.1  | 0.2 | 0.2 | 0   | -0.0692769266303063  |  -0.0692769266303063\n",
      "0.1  | 0.2 | 0.3 | 0   | -0.03598114900309023  |  -0.03598114900309025\n",
      "0.2  | 0.0 | 0.1 | 0   | -0.17052831677044225  |  -0.17052831677044225\n",
      "0.2  | 0.0 | 0.2 | 0   | -0.07435844575124662  |  -0.07435844575124662\n",
      "0.2  | 0.0 | 0.3 | 0   | -0.03725764308096076  |  -0.037257643080960766\n",
      "0.2  | 0.1 | 0.1 | 0   | -0.10180946284421462  |  -0.10180946284421463\n",
      "0.2  | 0.1 | 0.2 | 0   | -0.046292612196881334  |  -0.046292612196881314\n",
      "0.2  | 0.1 | 0.3 | 0   | -0.023508968398220604  |  -0.02350896839822061\n",
      "0.2  | 0.2 | 0.1 | 0   | -0.03201880243201008  |  -0.03201880243201009\n",
      "0.2  | 0.2 | 0.2 | 0   | -0.01600152779406204  |  -0.016001527794062054\n",
      "0.2  | 0.2 | 0.3 | 0   | -0.008418990785317684  |  -0.008418990785317689\n"
     ]
    }
   ],
   "source": [
    "# Make error array.\n",
    "relerror = np.zeros(27)\n",
    "\n",
    "print('Comparing modified version and original')\n",
    "print('================================================================================================')\n",
    "print(' kx  | ky  | qx  | qy  | Ds          | modDs  ')\n",
    "print('================================================================================================')\n",
    "for i in range(0, 3, 1):\n",
    "    for j in range(0, 3, 1):\n",
    "        for k in range(1, 4, 1):\n",
    "            xin = [i/10, j/10, k/10, 0]\n",
    "            ds_result = Ds(i/10, j/10, k/10, 0).real\n",
    "            modds_result = modDs_real(xin)\n",
    "            print('%2.1f  | %2.1f | %2.1f | 0   |'%(i/10, j/10, k/10), ds_result, ' | ', modds_result)\n",
    "            relerror[i+j+k-1] = abs((modds_result / ds_result.real) - 1)\n",
    "            "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Comparing modified version and original\n",
      "================================================================================================\n",
      " kx  | ky  | qx  | qy  | rel error  \n",
      "================================================================================================\n",
      "0.0  | 0.0 | 0.1 | 0   | 4.440892098500626e-16\n",
      "0.0  | 0.0 | 0.2 | 0   | 6.661338147750939e-16\n",
      "0.0  | 0.0 | 0.3 | 0   | 0.0\n",
      "0.0  | 0.1 | 0.1 | 0   | 6.661338147750939e-16\n",
      "0.0  | 0.1 | 0.2 | 0   | 0.0\n",
      "0.0  | 0.1 | 0.3 | 0   | 2.220446049250313e-16\n",
      "0.0  | 0.2 | 0.1 | 0   | 0.0\n",
      "0.0  | 0.2 | 0.2 | 0   | 2.220446049250313e-16\n",
      "0.0  | 0.2 | 0.3 | 0   | 4.440892098500626e-16\n",
      "0.1  | 0.0 | 0.1 | 0   | 6.661338147750939e-16\n",
      "0.1  | 0.0 | 0.2 | 0   | 0.0\n",
      "0.1  | 0.0 | 0.3 | 0   | 2.220446049250313e-16\n",
      "0.1  | 0.1 | 0.1 | 0   | 0.0\n",
      "0.1  | 0.1 | 0.2 | 0   | 2.220446049250313e-16\n",
      "0.1  | 0.1 | 0.3 | 0   | 4.440892098500626e-16\n",
      "0.1  | 0.2 | 0.1 | 0   | 2.220446049250313e-16\n",
      "0.1  | 0.2 | 0.2 | 0   | 4.440892098500626e-16\n",
      "0.1  | 0.2 | 0.3 | 0   | 8.881784197001252e-16\n",
      "0.2  | 0.0 | 0.1 | 0   | 0.0\n",
      "0.2  | 0.0 | 0.2 | 0   | 2.220446049250313e-16\n",
      "0.2  | 0.0 | 0.3 | 0   | 4.440892098500626e-16\n",
      "0.2  | 0.1 | 0.1 | 0   | 2.220446049250313e-16\n",
      "0.2  | 0.1 | 0.2 | 0   | 4.440892098500626e-16\n",
      "0.2  | 0.1 | 0.3 | 0   | 8.881784197001252e-16\n",
      "0.2  | 0.2 | 0.1 | 0   | 4.440892098500626e-16\n",
      "0.2  | 0.2 | 0.2 | 0   | 8.881784197001252e-16\n",
      "0.2  | 0.2 | 0.3 | 0   | 6.661338147750939e-16\n",
      "================================================================================================\n",
      "The average error of modified function is  3.7007434154171886e-16\n"
     ]
    }
   ],
   "source": [
    "errorsum = 0\n",
    "print('Comparing modified version and original')\n",
    "print('================================================================================================')\n",
    "print(' kx  | ky  | qx  | qy  | rel error  ')\n",
    "print('================================================================================================')\n",
    "for i in range(0, 3, 1):\n",
    "    for j in range(0, 3, 1):\n",
    "        for k in range(1, 4, 1):\n",
    "            print('%2.1f  | %2.1f | %2.1f | 0   |'%(i/10, j/10, k/10), relerror[i+j+k-1])\n",
    "            errorsum = errorsum + relerror[i+j+k-1]\n",
    "           \n",
    "avgerror = errorsum / (27)            \n",
    "print('================================================================================================')\n",
    "print('The average error of modified function is ', avgerror)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
